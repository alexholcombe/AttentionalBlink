# This script takes the model outputs generated by AB_Model_Single and
# AB_Model_Dual, compares them, and extracts the parameters from the best
# model. Nothing is saved automatically, but the script generates summary
# figures of the parameters for each sample.
#
# You should have a folder named 'ModelOutput', where the model output from
# AB_Model_Single and AB_Model_Dual (which will be called something like
# 'ModelOutput_ThisSample_Single.mat' & 'ModelOutput_ThisSample_Dual.mat')
# should be. You should also have a folder named 'Data', where the compiled
# data from each sample should be (called something like
# 'CompiledData_ThisSample.mat').
#
# The script requires the Econometrics Toolbox, specifically the function
# aicbic(), for calculation of the Bayesian Information Criterion. It also
# requires the Statistics Toolbox, for the nanmean() function, and possibly
# some other things.

# -------------------------------------------------------------------------
# -------------------------------------------------------------------------
# This section contains some things that will need to be set locally,
# depending on your directory structure and your data.

# Provide the path.
thisPath <- '/Users/experimentalmode/Documents/MATLAB/ABFinal/'

# Provide a name for each sample,
# so files can be read and written with corresponding filenames.
sampleNames <- {'Warwick','MIT','Western','Berkeley','SydneyObject','SydneyWord'}

# Provide some properties of the data for each sample, in order.
allRates <- [11.1 12 12 10 9.4 9.4]# Item rate (items/sec)
allNParticipants <- [20 11 12 12 32 31]# Number of participants
allNLags <- [10 10 10 7 7 7]# Number of lags

# Specify a set of standard lags (in ) for analysis across datasets. If
# all sets have the same item rate and number of lags, this could just be
# the list of lags multiplied by the inverse of item rate (i.e. the actual
# lags in ms). If not, a sensible set of values that spans the range should
# be specified.
standardLags <- 100:100:800

# Set the alpha value for t-tests
alphaVal <- .05

# Provide some paramater limits for accepting or rejecting models.

# You might want to set a minimum efficacy to accept a model when you don't
# have many trials per lag. If efficacy is very low, estimates for latency
# and precision are going to be based on very few trials and could be way
# off.
efficacyLimit <- 0.1

# The following two parameters should generally be set just a fraction
# below the limits that were set during model fitting. This stops us from
# accepting a model where the parameter estimates converged at the limit,
# suggesting it's no good.
latencyLimit <- 3.9
precisionLimit <- 3.9

# You might also want to specify a minimum number of participants required
# for a mean estimate to be generated at a given lag. If you only have one
# or two participants with accepted models at a certain lag, the mean
# parameter estimates might have a lot of noise. The way the figures are
# plotted, this is circumvented somewhat by making the darkness of the icon
# proportional to the number of participants contributing to that estimate.
minEstimates <- 0.01

# Set the size of the analysis window for the Vul, Nieuwenstein & Kanwisher
# (2008) equation-based analysis.
windowMin <- -3
windowMax <- +3

# Set the colours used in the plots.
plotColor <- {'r','c','k'}
plotIcon <- {'ro-','cs:','ko-'}
thisRGB <- 1# Which RGB channel(s) correspond to the first color ('r')?

sampleColor <- {'r','g','b','c','m','y'}
sampleIcon <- {'r^-','go-','bp-','cs-','md-','yv-'}
zeroPointY <- -50# Y-value at which to show zero crossing
modelAxes <- [-100 1100 -80 280]

interpType <- 'pchip'

# -------------------------------------------------------------------------
# -------------------------------------------------------------------------

# Add folders to the MATLAB path
addpath(genpath(thisPath))

# Calculate the multiplication factor to turn lags into
allFactors <- 1000./allRates

# Calculate the number of samples
nSamples <- numel(sampleNames)

# Make some matrices for keeping track of included and excluded models
allIncluded_T1 <- zeros(1,nSamples)
allIncluded_T2 <- zeros(1,nSamples)
dumpedOnPrecisionLimit <- zeros(1,nSamples)
dumpedOnLatencyLimit <- zeros(1,nSamples)
dumpedOnEfficacyLimit <- zeros(1,nSamples)

# Make some matrices for storing individual data for analysis across
# datasets. There is one set for each of accuracy, efficacy, latency and
# precision. The third dimensions separate data by target (1=T1, 2=T2), and
# the fourth dimensions by analysis type (1=Model, 2=Formula). The fourth
# dimensions are omitted for accuracy measures, because they don't rely on
# the model or formula analyses.

nStandardLags <- numel(standardLags)# Number of standard lags by
nParticipantsTotal <- sum(allNParticipants)# Number of participants

standardAccuracy <- NaN(nParticipantsTotal,nStandardLags,2)
standardEfficacy <- NaN(nParticipantsTotal,nStandardLags,2,2)
standardLatency <- NaN(nParticipantsTotal,nStandardLags,2,2)
standardPrecision <- NaN(nParticipantsTotal,nStandardLags,2,2)

# Create a figure for plotting the difference in BIC between single-episode
# and dual-episode models across all samples.
BIC_Figure <- figure('color','white','name','Model Preference')
plot(modelAxes(1:2),zeros(1,2),'k:')# Draw a line across zero
hold on

# Turn off the warning about NaN values during interpolation, which will be
# ignored.
warning('off', 'MATLAB:interp1:NaNstrip')

for (thisSample in 1:nSamples){

    # Fetch number of participants for this sample
    nParticipants <- allNParticipants(thisSample)

    # Load data for the dual-episode model (M2)
    cd([thisPath 'ModelOutput'])
    load(['ModelOutput_' sampleNames{thisSample} '_Dual.mat'])

    # Extract estimates for T2 parameters
    estimatesT2 <- allT2Estimates_byParticipant

    # Extract the likelihood of the dual-episode model from the combined
    # T1 and T2 distribution, and other parameters for model comparison
    dualModelMinNegLogLikelihood <- allT1T2MinNegLogLikelihoods_byParticipant
    dualModelPara <- nFreeParameters
    dualModelObs <- 2*nTrialsPerLag# 2x because there is a report for both T1 and T2 on each trial

    # Calculate lag parameters
    lagFactor <- allFactors(thisSample)
    nLags <- size(estimatesT2,2)
    lagList <- lagFactor*(1:nLags)

    # Load data for the single-episode model (M2)
    load(['ModelOutput_' sampleNames{thisSample} '_Single.mat'])

    # Extract estimates for T1 parameters
    estimatesT1 <- allT1Estimates_byParticipant

    # Extract the likelihood of the dual-episode model from the combined
    # T1 and T2 distribution, and other parameters for model comparison
    singleModelMinNegLogLikelihood <- allT1T2MinNegLogLikelihoods_byParticipant
    singleModelPara <- nFreeParameters
    singleModelObs <- 2*nTrialsPerLag# 2x because there is a report for both T1 and T2 on each trial

    # Calculate Bayesian Information Criteria (BIC) for the single- and
    # dual-episode models, based on the combined T1 and T2 distribution, to
    # determine when there is evidence of a second attentional episode.

    # First, set up some empty matrices
    allSingleBIC <- NaN(nParticipants,nLags)
    allDualBIC <- NaN(nParticipants,nLags)
    transitionPointByParticipant <- NaN(nParticipants,1)
    transitionPointRaw <- NaN(nParticipants,1)

    # Then do calculations for each participant
    for (thisParticipant in 1:nParticipants){

        # Calculate BIC for the single-episode model
        [singleAIC, singleBIC] <- aicbic(-singleModelMinNegLogLikelihood(thisParticipant,:),singleModelPara, singleModelObs)
        # Calculate BIC for the dual-episode model
        [dualAIC, dualBIC] <- aicbic(-dualModelMinNegLogLikelihood(thisParticipant,:),dualModelPara, dualModelObs)
        # Store in the data matrices
        allSingleBIC(thisParticipant,:) <- singleBIC
        allDualBIC(thisParticipant,:) <- dualBIC

        # Calculate a 'transition point', the last lag at which M1 is the
        # preferred model. Add 0.5 so we can use an strict inequality
        # operator to determine which model to use at a certain lag.
        thisComparison <- singleBIC > dualBIC
        thisCompResult <- find(!thisComparison, 1, 'last') + 0.5

        # Allow for the possibility that M2 is never preferred
        if (!isempty(thisCompResult)){
            transitionPointByParticipant(thisParticipant) <- thisCompResult
        } else {
            transitionPointByParticipant(thisParticipant) <- length(thisComparison) + 0.5
        }

        # Caluclate a non-quantized transition point for the purposes of
        # the meta-analysis. Because there, everything is mapped to a set
        # of standard lags.
        modelDiff <- singleBIC-dualBIC){
        zeroPoint <- find(modelDiff==0, 1)){# Just in case one happens to be exactly zero

        if (transitionPointByParticipant(thisParticipant) == (length(thisComparison) + 0.5)){

            transitionPointRaw(thisParticipant) <- transitionPointByParticipant(thisParticipant)

        } else if (isempty(zeroPoint)){

            startLag <- round(thisCompResult - 0.5)
            }Lag <- round(thisCompResult + 0.5)
            thisSlope <- fit((startLag:}Lag)', modelDiff(startLag:}Lag)', 'poly1')){# Fit a linear function
            transitionPointRaw(thisParticipant) <- -thisSlope.p2/thisSlope.p1# Get the intercept

        } else {

            transitionPointRaw(thisParticipant) <- zeroPoint

        }

    }

    # Summarise the BIC comparison for this sample in a figure.
    figure(BIC_Figure)
    hold on

    # Calculate means.
    modelComlastLag <- nanmean(allSingleBIC-allDualBIC)
    modelCompSD <- nanstd(allSingleBIC-allDualBIC)
    modelCompSEM <- modelCompSD/sqrt(nParticipants)

    # Plot errorbars.
    for (thisLag in 1:nLags){
        line(lagList(thisLag)*ones(1,2), [-modelCompSEM(thisLag) modelCompSEM(thisLag)]+modelComlastLag(thisLag), 'color', sampleColor{thisSample})
    }

    # Plot icons.
    plot(lagList,modelComlastLag,sampleIcon{thisSample})

    # Work out the zero point by linear interpolation.
    zeroPoint <- lagList(find(modelComlastLag==0, 1))# Just in case one happens to be exactly zero

    if (isempty(zeroPoint)){

        lastLag <- find(diff(sign(modelComlastLag)), 1)){# Find where negative becomes positive
        thisSlope <- fit(lagList(lastLag:lastLag+1)', modelComlastLag(lastLag:lastLag+1)', 'poly1')# Fit a linear function
        zeroPoint <- -thisSlope.p2/thisSlope.p1# Get the intercept

    }

    # Plot the zero point.
    line(zeroPoint*ones(1,2), [modelAxes(3) 0], 'color', sampleColor{thisSample}, 'LineStyle', ':')
    plot(zeroPoint,zeroPointY,sampleIcon{thisSample})

    # Create matrices for storing final model parameters
    allEfficacy_E1 <- NaN(nParticipants,nLags)
    allEfficacy_E2 <- NaN(nParticipants,nLags)

    allLatency_E1 <- NaN(nParticipants,nLags)
    allLatency_E2 <- NaN(nParticipants,nLags)

    allPrecision_E1 <- NaN(nParticipants,nLags)
    allPrecision_E2 <- NaN(nParticipants,nLags)

    # Cycle through each lag and participant
    for (thisLag in 1:nLags){
        for (thisParticipant in 1:nParticipants){

            # First, enter final parameters for T1. We use M1
            # (single-episode model) because error distributions indicate
            # that T2-selections are not reported as T1. M1 provides more
            # stable fits because M2 is occasionally over-fit to random
            # perturbations in the data.

            # Check the parameters satisfy the bounds set earlier
            noGoodE <- abs(estimatesT1(thisParticipant,thisLag,1)) < efficacyLimit
            noGoodL <- abs(estimatesT1(thisParticipant,thisLag,2)) > latencyLimit
            noGoodP <- abs(estimatesT1(thisParticipant,thisLag,3)) > precisionLimit

            # If they don't, add it to the tally of rejected models
            noGood <- any([noGoodE noGoodL noGoodP])
            dumpedOnEfficacyLimit(thisSample) <- dumpedOnEfficacyLimit(thisSample) + noGoodE
            dumpedOnLatencyLimit(thisSample) <- dumpedOnLatencyLimit(thisSample) + noGoodL
            dumpedOnPrecisionLimit(thisSample) <- dumpedOnPrecisionLimit(thisSample) + noGoodP

            # Otherwise, include these as final model parameters
            if (!noGood){
                allIncluded_T1(thisSample) <- allIncluded_T1(thisSample) + 1
                allEfficacy_E1(thisParticipant,thisLag) <- estimatesT1(thisParticipant,thisLag,1)
                allLatency_E1(thisParticipant,thisLag) <- estimatesT1(thisParticipant,thisLag,2)
                allPrecision_E1(thisParticipant,thisLag) <- estimatesT1(thisParticipant,thisLag,3)
            }

            # Next, check whether this lag is earlier than the
            # participant's transition point. If it is, then we don't enter
            # anything for the second episode.

            if (thisLag > transitionPointByParticipant(thisParticipant)){

                # There is evidence of a second episode.

                # Check whether a switch in the order of parameters is
                # required. When the parameter limits overlap, T1 and and
                # T2 episode estimates can get switched around. We take the
                # later one to be T2.

                if (estimatesT2(thisParticipant,thisLag,2) < estimatesT2(thisParticipant,thisLag,5)){
                    # Switch the T2 parameters into the first three cells
                    estimatesT2(thisParticipant,thisLag,1) <- estimatesT2(thisParticipant,thisLag,4)
                    estimatesT2(thisParticipant,thisLag,2) <- estimatesT2(thisParticipant,thisLag,5)
                    estimatesT2(thisParticipant,thisLag,3) <- estimatesT2(thisParticipant,thisLag,6)
                }

                # Check all parameters satisfy the bounds set earlier
                noGoodE <- abs(estimatesT2(thisParticipant,thisLag,1)) < efficacyLimit# Only check the T2 parameter here
                noGoodL <- [abs(estimatesT2(thisParticipant,thisLag,2)) abs(estimatesT2(thisParticipant,thisLag,5)+listLags(thisLag))] > latencyLimit
                noGoodP <- [abs(estimatesT2(thisParticipant,thisLag,3)) abs(estimatesT2(thisParticipant,thisLag,6))] > precisionLimit

                # If they don't, add it to the tally of rejected models
                noGood <- any([noGoodE noGoodL noGoodP])
                dumpedOnEfficacyLimit(thisSample) <- dumpedOnEfficacyLimit(thisSample) + any(noGoodE)
                dumpedOnLatencyLimit(thisSample) <- dumpedOnLatencyLimit(thisSample) + any(noGoodL)
                dumpedOnPrecisionLimit(thisSample) <- dumpedOnPrecisionLimit(thisSample) + any(noGoodP)

                # Otherwise, include these as final model parameters
                if (!noGood){
                    allIncluded_T2(thisSample) <- allIncluded_T2(thisSample) + 1
                    allEfficacy_E2(thisParticipant,thisLag) <- estimatesT2(thisParticipant,thisLag,1)
                    allLatency_E2(thisParticipant,thisLag) <- estimatesT2(thisParticipant,thisLag,2)
                    allPrecision_E2(thisParticipant,thisLag) <- estimatesT2(thisParticipant,thisLag,3)
                }

            }
        }
    }

    # Now we have data matrices with parameters from all accepted models.
    # Next, we combine them to get summary statistics.

    # First, for T2:

        # Transfer data to new matrices, with latency and precision expressed
        # in ms rather than items.
        T2_efficacy <- allEfficacy_E2
        T2_latency <- allLatency_E2*lagFactor
        T2_precision <- allPrecision_E2*lagFactor

        # Calculate mean parameters across participants.
        T2_efficacy_M <- nanmean(T2_efficacy)
        T2_latency_M <- nanmean(T2_latency)
        T2_precision_M <- nanmean(T2_precision)

        # Calculate standard deviations across participants.
        T2_efficacy_SD <- nanstd(T2_efficacy)
        T2_latency_SD <- nanstd(T2_latency)
        T2_precision_SD <- nanstd(T2_precision)

        # Tally the number of participants contributing to these means.
        T2_nEstimates <- sum(!isnan(T2_efficacy))

        # Ensure that the number of participants meets the criterion set above,
        # otherwise set the means and standard deviations as undefined.
        minMet <- T2_nEstimates > minEstimates
        T2_efficacy_M(!minMet) <- NaN
        T2_latency_M(!minMet) <- NaN
        T2_precision_M(!minMet) <- NaN
        T2_efficacy_SD(!minMet) <- NaN
        T2_latency_SD(!minMet) <- NaN
        T2_precision_SD(!minMet) <- NaN

        # Calculate the standard error of the mean.
        T2_efficacy_SEM <- T2_efficacy_SD./sqrt(T2_nEstimates)
        T2_latency_SEM <- T2_latency_SD./sqrt(T2_nEstimates)
        T2_precision_SEM <- T2_precision_SD./sqrt(T2_nEstimates)

    # Then, for T1:

        # Transfer data to new matrices, with latency and precision expressed
        # in ms rather than items.
        T1_efficacy <- allEfficacy_E1
        T1_latency <- allLatency_E1*lagFactor
        T1_precision <- allPrecision_E1*lagFactor

        # Calculate mean parameters across participants.
        T1_efficacy_M <- nanmean(T1_efficacy)
        T1_latency_M <- nanmean(T1_latency)
        T1_precision_M <- nanmean(T1_precision)

        # Calculate standard deviations across participants.
        T1_efficacy_SD <- nanstd(T1_efficacy)
        T1_latency_SD <- nanstd(T1_latency)
        T1_precision_SD <- nanstd(T1_precision)

        # Tally the number of participants contributing to these means.
        T1_nEstimates <- sum(!isnan(T1_efficacy))

        # Ensure that the number of participants meets the criterion set above,
        # otherwise set the means and standard deviations as undefined.
        minMet <- T1_nEstimates > minEstimates
        T1_efficacy_M(!minMet) <- NaN
        T1_latency_M(!minMet) <- NaN
        T1_precision_M(!minMet) <- NaN
        T1_efficacy_SD(!minMet) <- NaN
        T1_latency_SD(!minMet) <- NaN
        T1_precision_SD(!minMet) <- NaN

        # Calculate the standard error of the mean.
        T1_efficacy_SEM <- T1_efficacy_SD./sqrt(T1_nEstimates)
        T1_latency_SEM <- T1_latency_SD./sqrt(T1_nEstimates)
        T1_precision_SEM <- T1_precision_SD./sqrt(T1_nEstimates)


    # Conduct t-tests as a rough guide to whether the parameter estimates
    # for T2 at each lag differ from a T1 baseline, which we consider to be
    # the T1 parameter at the longest lag.

    # Create empty matrices to store p-values
    pVals_E <- NaN(1,nLags)
    pVals_L <- NaN(1,nLags)
    pVals_P <- NaN(1,nLags)

    # Cycle through each lag to conduct the t-tests
    for (thisLag in 1:nLags){

        # Check first to make sure there is more than one estimate, so that
        # a t-test can be conducted.
        if (sum( !isnan(T2_efficacy(:,thisLag)) & !isnan(nanmean(T1_efficacy,2)) ) > 1){

            # Efficacy t-test
            [h,p] <- ttest(T2_efficacy(:,thisLag),nanmean(T1_efficacy,2))
            pVals_E(thisLag) <- p

            # Latency t-test
            [h,p] <- ttest(T2_latency(:,thisLag),nanmean(T1_latency,2))
            pVals_L(thisLag) <- p

            # Precision t-test
            [h,p] <- ttest(T2_precision(:,thisLag),nanmean(T1_precision,2))
            pVals_P(thisLag) <- p

        }

    }

    # ---------------------------------------------------------------------
    # This section contains code for printing the outcome of these t-tests
    # to the command window.

    fprintf('\n\nSAMPLE %d: %s\n', thisSample, sampleNames{thisSample})
    fprintf('\nEfficacy\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_E(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_E(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    fprintf('\nLatency\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_L(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_L(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    fprintf('\nPrecision\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_P(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_P(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    # ---------------------------------------------------------------------
    # This section contains code for creating the figure of T1 parameter
    # estimates.

    T1_Figure <- figure('color','white','name',[sampleNames{thisSample} ': T1 Parameters'])

    # Plot efficacy
    subplot(1,4,2)
    colormap gray
    hold on

        # Draw the errorbars, with darkness indicating the proportion of
        # participants contributing to the estimate.
        lagColors <- 1-repmat((T1_nEstimates/nParticipants)',1,3)
        lagColors(:,thisRGB) <- ones(size(lagColors(:,thisRGB)))

        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1_efficacy_SEM(thisLag)*[-1 1]+T1_efficacy_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
            lagColor <- ones(1,3)*1-(T1_nEstimates(thisLag)/nParticipants)
            lagColor(thisRGB) <- 1
            line([lagList(thisLag) lagList(thisLag+1)],[T1_efficacy_M(thisLag) T1_efficacy_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T1_efficacy_M,[],lagColors)

    # Plot latency
    subplot(1,4,3)
    hold on

        # Draw the errorbars for each lag.
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1_latency_SEM(thisLag)*[-1 1]+T1_latency_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
            line([lagList(thisLag) lagList(thisLag+1)],[T1_latency_M(thisLag) T1_latency_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T1_latency_M,[],lagColors)

    # Plot precision
    subplot(1,4,4)
    hold on

        # Draw the errorbars for each lag.
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1_precision_SEM(thisLag)*[-1 1]+T1_precision_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
                line([lagList(thisLag) lagList(thisLag+1)],[T1_precision_M(thisLag) T1_precision_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T1_precision_M,[],lagColors)

    # ---------------------------------------------------------------------
    # This section contains code for creating the figure of T2 parameter
    # estimates.

    T2_Figure <- figure('color','white','name',[sampleNames{thisSample} ': T2 Parameters'])

    # Plot efficacy
    subplot(1,4,2)
    colormap gray
    hold on

        # Draw the errorbars, with darkness indicating the proportion of
        # participants contributing to the estimate.
        lagColors <- 1-repmat((T2_nEstimates/nParticipants)',1,3)
        lagColors(:,thisRGB) <- ones(size(lagColors(:,thisRGB)))

        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2_efficacy_SEM(thisLag)*[-1 1]+T2_efficacy_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
            line([lagList(thisLag) lagList(thisLag+1)],[T2_efficacy_M(thisLag) T2_efficacy_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T2_efficacy_M,[],lagColors)

    # Plot latency
    subplot(1,4,3)
    hold on

        # Draw the errorbars for each lag.
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2_latency_SEM(thisLag)*[-1 1]+T2_latency_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
            line([lagList(thisLag) lagList(thisLag+1)],[T2_latency_M(thisLag) T2_latency_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T2_latency_M,[],lagColors)

    # Plot precision
    subplot(1,4,4)
    hold on

        # Draw the errorbars for each lag.
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2_precision_SEM(thisLag)*[-1 1]+T2_precision_M(thisLag), 'Color', lagColors(thisLag,:))
        }

        # Draw the lines joining icons for each lag.
        for (thisLag in 1:nLags-1){
                line([lagList(thisLag) lagList(thisLag+1)],[T2_precision_M(thisLag) T2_precision_M(thisLag+1)], 'Color', lagColors(thisLag,:))
        }

        # Draw the icons for each lag.
        scatter(lagList,T2_precision_M,[],lagColors)

    # ---------------------------------------------------------------------
    # Now we perform these analyses again, using the Vul, Nieuwenstein
    # & Kanwisher (2008) equations. Along the way, we'll also calculate raw
    # accuracy for T1 and T2, and T1-contingent accuracy for T2.

    # Load the data.
    cd([thisPath 'Data'])
    load(['CompiledData_' sampleNames{thisSample} '.mat'])

    # Calculate the size of the analysis window.
    windowEls <- windowMin:windowMax
    nWindow <- numel(windowEls)

    # Create some matrices to store parameter estimates
    T1Efficacy <- NaN(nParticipants,nLags)
    T2Efficacy <- NaN(nParticipants,nLags)
    T1Latency <- NaN(nParticipants,nLags)
    T2Latency <- NaN(nParticipants,nLags)
    T1Precision <- NaN(nParticipants,nLags)
    T2Precision <- NaN(nParticipants,nLags)
    T1Performance in NaN(nParticipants,nLags)){
    T2Performance in NaN(nParticipants,nLags)){
    T2GivenT1Performance in NaN(nParticipants,nLags)){

    # Cycle through each participant
    for (thisParticipant in 1:nParticipants){

        # Extract the relevant lags, T1 errors and T2 errors
        theseLags <- allLags(thisParticipant,:,:)
        theseT1Error <- allT1Error(thisParticipant,:,:)
        theseT2Error <- allT2Error(thisParticipant,:,:)

        # Cycle through each lag
        for (thisLag in 1:nLags){

            # Extract the relevant T1 and T2 errors for this lag
            lagT1Error <- theseT1Error(theseLags==thisLag)
            lagT2Error <- theseT2Error(theseLags==thisLag)

            # Calculate how many data points are there
            nError <- numel(lagT1Error)

            # Calculate efficacy. This is the proportion of errors that
            # fall within the defined window. Vul et al. normalise this by
            # the size of the selection window (i.e. our variable nWindow),
            # but we leave out this step for better compatibility with our
            # efficacy measure.
            T1Efficacy(thisParticipant,thisLag) <- sum((lagT1Error>=windowMin)&(lagT1Error<=windowMax))/nError
            T2Efficacy(thisParticipant,thisLag) <- sum((lagT2Error>=windowMin)&(lagT2Error<=windowMax))/nError

            # Calculate latency. This is the mean of errors in the defined
            # window.
            T1Latency(thisParticipant,thisLag) <- mean(lagT1Error((lagT1Error>=windowMin)&(lagT1Error<=windowMax)))
            T2Latency(thisParticipant,thisLag) <- mean(lagT2Error((lagT2Error>=windowMin)&(lagT2Error<=windowMax)))

            # Calculate precision. This is the standard deviation of errors
            # in the defined window. Vul et al. report the variance (i.e.
            # the square of the standard deviation), but we leave out this
            # step for better compatibility with our precision measure.
            T1Precision(thisParticipant,thisLag) <- std(lagT1Error((lagT1Error>=windowMin)&(lagT1Error<=windowMax)))
            T2Precision(thisParticipant,thisLag) <- std(lagT2Error((lagT2Error>=windowMin)&(lagT2Error<=windowMax)))

            # Calculate the number of exactly correct responses.
            T1Correct <- sum(lagT1Error==0)
            T2Correct <- sum(lagT2Error==0)
            T2GivenT1 <- sum((lagT1Error==0)&(lagT2Error==0))

            # Calculate the proportion of exactly correct responses.
            T1Performance(thisParticipant,thisLag) in T1Correct/nError){
            T2Performance(thisParticipant,thisLag) in T2Correct/nError){
            T2GivenT1Performance(thisParticipant,thisLag) in T2GivenT1/T1Correct){

        }

    }

    # Convert latency and precision to ms rather than items.
    T1Latency <- T1Latency*lagFactor
    T2Latency <- T2Latency*lagFactor
    T1Precision <- T1Precision*lagFactor
    T2Precision <- T2Precision*lagFactor

    # Calculate mean, SD and SEM across participants for T1 efficacy.
    T1EfficacyM <- mean(T1Efficacy)
    T1EfficacySD <- std(T1Efficacy)
    T1EfficacySEM <- T1EfficacySD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T2 efficacy.
    T2EfficacyM <- mean(T2Efficacy)
    T2EfficacySD <- std(T2Efficacy)
    T2EfficacySEM <- T2EfficacySD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T1 latency.
    T1LatencyM <- mean(T1Latency)
    T1LatencySD <- std(T1Latency)
    T1LatencySEM <- T1LatencySD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T2 latency.
    T2LatencyM <- mean(T2Latency)
    T2LatencySD <- std(T2Latency)
    T2LatencySEM <- T2LatencySD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T1 precision.
    T1PrecisionM <- mean(T1Precision)
    T1PrecisionSD <- std(T1Precision)
    T1PrecisionSEM <- T1PrecisionSD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T2 precision.
    T2PrecisionM <- mean(T2Precision)
    T2PrecisionSD <- std(T2Precision)
    T2PrecisionSEM <- T2PrecisionSD/sqrt(nParticipants)

    # Calculate mean, SD and SEM across participants for T1 performance
    # (exactly correct reports).
    T1PerformanceM in mean(T1Performance)){
    T1PerformanceSD in std(T1Performance)){
    T1PerformanceSEM in T1PerformanceSD/sqrt(nParticipants)){

    # Calculate mean, SD and SEM across participants for T2 contingent
    # performance (T2 given T1 is correct).
    T2GivenT1PerformanceM in mean(T2GivenT1Performance)){
    T2GivenT1PerformanceSD in std(T2GivenT1Performance)){
    T2GivenT1PerformanceSEM in T2GivenT1PerformanceSD/sqrt(nParticipants)){


    # Conduct t-tests as a rough guide to whether the parameter estimates
    # for T2 at each lag differ from a T1 baseline.

    # Create empty matrices to store p-values
    pVals <- NaN(1,nLags)
    pVals_E <- NaN(1,nLags)
    pVals_L <- NaN(1,nLags)
    pVals_P <- NaN(1,nLags)

    # Cycle through each lag to conduct the t-tests
    for (thisLag in 1:nLags){

        # T2 contingent accuracy t-test
        [h,p] in ttest(T2GivenT1Performance(:,thisLag),nanmean(T1Performance,2))){
        pVals(thisLag) <- p

        # Efficacy t-test
        [h,p] <- ttest(T2Efficacy(:,thisLag),nanmean(T1Efficacy,2))
        pVals_E(thisLag) <- p

        # Latency t-test
        [h,p] <- ttest(T2Latency(:,thisLag),nanmean(T1Latency,2))
        pVals_L(thisLag) <- p

        # Precision t-test
        [h,p] <- ttest(T2Precision(:,thisLag),nanmean(T1Precision,2))
        pVals_P(thisLag) <- p

    }

    # ---------------------------------------------------------------------
    # This section contains code for printing the outcome of these t-tests
    # to the command window.

    fprintf('\nContingent Accuracy\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d ', pVals(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    fprintf('\nEfficacy (Formula)\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_E(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_E(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    fprintf('\nLatency (Formula)\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_L(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_L(thisL) < alphaVal)
    }
    fprintf('\t|\n')

    fprintf('\nPrecision (Formula)\n')

    for (thisL in 1:nLags){
        fprintf('\t| Lag %d', thisL)
    }
    fprintf('\t|\n')

    fprintf('P')
    for (thisL in 1:nLags){
        fprintf('\t| %.3f', pVals_P(thisL))
    }
    fprintf('\t|\n')

    fprintf('H')
    for (thisL in 1:nLags){
        fprintf('\t| %d', pVals_P(thisL) < alphaVal)
    }

    fprintf('\t|\n\n\n')

    # ---------------------------------------------------------------------
    # This section contains code for creating the figure of T1 parameter
    # estimates.

    # Select the T1 figure
    figure(T1_Figure)

    # Plot efficacy
    subplot(1,4,2)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
           line([lagList(thisLag) lagList(thisLag)],T1EfficacySEM(thisLag)*[-1 1]+T1EfficacyM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T1EfficacyM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -0.1 1.1])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # Plot latency
    subplot(1,4,3)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1LatencySEM(thisLag)*[-1 1]+T1LatencyM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T1LatencyM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -180 180])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # Plot precision
    subplot(1,4,4)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1PrecisionSEM(thisLag)*[-1 1]+T1PrecisionM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T1PrecisionM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -20 220])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on','YDir','Reverse')
        box on
        axis square

    # Plot accuracy
    subplot(1,4,1)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T1PerformanceSEM(thisLag)*[-1 1]+T1PerformanceM(thisLag), 'Color', plotColor{3})){
        }

        # Plot parameter estimates
        plot(lagList,T1PerformanceM,plotIcon{3})){

        # Set axis properties
        axis([-100 1100 -0.1 1.1])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # ---------------------------------------------------------------------
    # This section contains code for creating the figure of T2 parameter
    # estimates.

    # Select the T2 figure
    figure(T2_Figure)

    # Plot efficacy
    subplot(1,4,2)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
           line([lagList(thisLag) lagList(thisLag)],T2EfficacySEM(thisLag)*[-1 1]+T2EfficacyM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T2EfficacyM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -0.1 1.1])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # Plot latency
    subplot(1,4,3)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2LatencySEM(thisLag)*[-1 1]+T2LatencyM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T2LatencyM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -180 180])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # Plot precision
    subplot(1,4,4)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2PrecisionSEM(thisLag)*[-1 1]+T2PrecisionM(thisLag), 'Color', plotColor{2})
        }

        # Plot parameter estimates
        plot(lagList,T2PrecisionM,plotIcon{2})

        # Set axis properties
        axis([-100 1100 -20 220])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on','YDir','Reverse')
        box on
        axis square

    # Plot contingent accuracy
    subplot(1,4,1)
    hold on

        # Draw errorbars
        for (thisLag in 1:nLags){
            line([lagList(thisLag) lagList(thisLag)],T2GivenT1PerformanceSEM(thisLag)*[-1 1]+T2GivenT1PerformanceM(thisLag), 'Color', plotColor{3})){
        }

        # Plot parameter estimates
        plot(lagList,T2GivenT1PerformanceM,plotIcon{3})){

        # Set axis properties
        axis([-100 1100 -0.1 1.1])
        set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
        box on
        axis square

    # Calculate values for meta-analysis. Use cubic interpolation for lags
    # between those actually tested.
    theseParticipants <- (1:nParticipants) + sum(allNParticipants(1:thisSample-1))

    for (thisParticipant in 1:nParticipants){

      standardAccuracy(theseParticipants(thisParticipant),:,1) in interp1(lagList,T1Performance(thisParticipant,:),standardLags,interpType)){
      standardAccuracy(theseParticipants(thisParticipant),:,2) in interp1(lagList,T2GivenT1Performance(thisParticipant,:),standardLags,interpType)){

      standardEfficacy(theseParticipants(thisParticipant),:,1,1) <- interp1(lagList,T1_efficacy(thisParticipant,:),standardLags,interpType)
      standardLatency(theseParticipants(thisParticipant),:,1,1) <- interp1(lagList,T1_latency(thisParticipant,:),standardLags,interpType)
      standardPrecision(theseParticipants(thisParticipant),:,1,1) <- interp1(lagList,T1_precision(thisParticipant,:),standardLags,interpType)

      # Do a quick check to make sure that values aren't all NaNs,
      # otherwise we'll get an error here.
      if (sum(!isnan(T2_efficacy(thisParticipant,:))) > 1){
          standardEfficacy(theseParticipants(thisParticipant),:,2,1) <- interp1(lagList,T2_efficacy(thisParticipant,:),standardLags,interpType)
          standardLatency(theseParticipants(thisParticipant),:,2,1) <- interp1(lagList,T2_latency(thisParticipant,:),standardLags,interpType)
          standardPrecision(theseParticipants(thisParticipant),:,2,1) <- interp1(lagList,T2_precision(thisParticipant,:),standardLags,interpType)
      }

      # Replace T2 parameters prior to the transition point (as these are
      # automatically extrapolated by interp1) with NaN. Previously, we
      # used a point half-way between the final lag at which M1 is best,
      # and the next lag. Because lags don't necessarily align with the
      # time points chosen, we restore this to be the first lag at which M2
      # is best. Then we set anything below this point to NaN.
      thisTransitionLag <- transitionPointRaw(thisParticipant)
      thisTransitionPoint <- lagFactor*thisTransitionLag
      nPoints <- sum(standardLags<thisTransitionPoint)
      standardEfficacy(theseParticipants(thisParticipant),1:nPoints,2,1) <- NaN(1,nPoints)
      standardLatency(theseParticipants(thisParticipant),1:nPoints,2,1) <- NaN(1,nPoints)
      standardPrecision(theseParticipants(thisParticipant),1:nPoints,2,1) <- NaN(1,nPoints)

      standardEfficacy(theseParticipants(thisParticipant),:,1,2) <- interp1(lagList,T1Efficacy(thisParticipant,:),standardLags,interpType)
      standardLatency(theseParticipants(thisParticipant),:,1,2) <- interp1(lagList,T1Latency(thisParticipant,:),standardLags,interpType)
      standardPrecision(theseParticipants(thisParticipant),:,1,2) <- interp1(lagList,T1Precision(thisParticipant,:),standardLags,interpType)

      standardEfficacy(theseParticipants(thisParticipant),:,2,2) <- interp1(lagList,T2Efficacy(thisParticipant,:),standardLags,interpType)
      standardLatency(theseParticipants(thisParticipant),:,2,2) <- interp1(lagList,T2Latency(thisParticipant,:),standardLags,interpType)
      standardPrecision(theseParticipants(thisParticipant),:,2,2) <- interp1(lagList,T2Precision(thisParticipant,:),standardLags,interpType)

    }

}

# Tidy up the BIC figure.
figure(BIC_Figure)
axis(modelAxes)
set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
box on
axis square

# Turn this warning back on.
warning('on', 'MATLAB:interp1:NaNstrip')

# -------------------------------------------------------------------------
# In the final sections, we make summary figures from the meta-analysis.
# -------------------------------------------------------------------------

# First, for T2:

    # Calculate mean parameters across participants.
    T2_accuracy_M <- nanmean(squeeze(standardAccuracy(:,:,2)))
    T2_efficacy_M <- nanmean(squeeze(standardEfficacy(:,:,2,1)))
    T2_latency_M <- nanmean(squeeze(standardLatency(:,:,2,1)))
    T2_precision_M <- nanmean(squeeze(standardPrecision(:,:,2,1)))

    # Calculate standard deviations across participants.
    T2_accuracy_SD <- nanstd(squeeze(standardAccuracy(:,:,2)))
    T2_efficacy_SD <- nanstd(squeeze(standardEfficacy(:,:,2,1)))
    T2_latency_SD <- nanstd(squeeze(standardLatency(:,:,2,1)))
    T2_precision_SD <- nanstd(squeeze(standardPrecision(:,:,2,1)))

    # Tally the number of participants contributing to these means.
    T2_nEstimates <- sum(!isnan(squeeze(standardEfficacy(:,:,2,1))))

    # Calculate the standard error of the mean.
    T2_accuracy_SEM <- T2_accuracy_SD./sqrt(nParticipantsTotal)
    T2_efficacy_SEM <- T2_efficacy_SD./sqrt(T2_nEstimates)
    T2_latency_SEM <- T2_latency_SD./sqrt(T2_nEstimates)
    T2_precision_SEM <- T2_precision_SD./sqrt(T2_nEstimates)

# Then, for T1:

    # Calculate mean parameters across participants.
    T1_accuracy_M <- nanmean(squeeze(standardAccuracy(:,:,1)))
    T1_efficacy_M <- nanmean(squeeze(standardEfficacy(:,:,1,1)))
    T1_latency_M <- nanmean(squeeze(standardLatency(:,:,1,1)))
    T1_precision_M <- nanmean(squeeze(standardPrecision(:,:,1,1)))

    # Calculate standard deviations across participants.
    T1_accuracy_SD <- nanstd(squeeze(standardAccuracy(:,:,1)))
    T1_efficacy_SD <- nanstd(squeeze(standardEfficacy(:,:,1,1)))
    T1_latency_SD <- nanstd(squeeze(standardLatency(:,:,1,1)))
    T1_precision_SD <- nanstd(squeeze(standardPrecision(:,:,1,1)))

    # Tally the number of participants contributing to these means.
    T1_nEstimates <- sum(!isnan(squeeze(standardEfficacy(:,:,1,1))))

    # Calculate the standard error of the mean.
    T1_accuracy_SEM <- T1_accuracy_SD./sqrt(nParticipantsTotal)
    T1_efficacy_SEM <- T1_efficacy_SD./sqrt(T1_nEstimates)
    T1_latency_SEM <- T1_latency_SD./sqrt(T1_nEstimates)
    T1_precision_SEM <- T1_precision_SD./sqrt(T1_nEstimates)

# Conduct t-tests as a rough guide to whether the parameter estimates
# for T2 at each lag differ from a T1 baseline, which we consider to be
# the T1 parameter at the longest lag.

# Create empty matrices to store p-values
nVals <- NaN(1,nStandardLags)
pVals_E <- NaN(1,nStandardLags)
pVals_L <- NaN(1,nStandardLags)
pVals_P <- NaN(1,nStandardLags)

# Cycle through each lag to conduct the t-tests
for (thisLag in 1:nStandardLags){

    # Check first to make sure there is more than one estimate, so that
    # a t-test can be conducted.
    if (sum( !isnan(squeeze(standardEfficacy(:,thisLag,2,1))) & !isnan(standardEfficacy(:,nStandardLags,1,1)) ) > 1){

        # Efficacy t-test
        [h,p] <- ttest(squeeze(standardEfficacy(:,thisLag,2,1)),standardEfficacy(:,nStandardLags,1,1))
        pVals_E(thisLag) <- p

        # Latency t-test
        [h,p] <- ttest(squeeze(standardLatency(:,thisLag,2,1)),standardLatency(:,nStandardLags,1,1))
        pVals_L(thisLag) <- p

        # Precision t-test
        [h,p] <- ttest(squeeze(standardPrecision(:,thisLag,2,1)),standardPrecision(:,nStandardLags,1,1))
        pVals_P(thisLag) <- p

        # Numberof participants
        nVals(thisLag) <- sum(!isnan(squeeze(standardEfficacy(:,thisLag,2,1))))

    }

}

# ---------------------------------------------------------------------
# This section contains code for printing the outcome of these t-tests
# to the command window.

fprintf('\n\nMETA-ANALYSIS')

fprintf('\nParticipants\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('N')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', nVals(thisL))
}
fprintf('\t|\n')

fprintf('%%')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.1f ', 100*(nVals(thisL)/nParticipantsTotal))
}
fprintf('\t|\n')

fprintf('\nEfficacy\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_E(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_E(thisL) < alphaVal)
}
fprintf('\t|\n')

fprintf('\nLatency\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_L(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_L(thisL) < alphaVal)
}
fprintf('\t|\n')

fprintf('\nPrecision\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_P(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_P(thisL) < alphaVal)
}
fprintf('\t|\n')


# ---------------------------------------------------------------------
# This section contains code for creating the figure of T1 parameter
# estimates.

T1_Figure <- figure('color','white','name','Meta-Analysis: T1 Parameters')

# Plot efficacy
subplot(1,4,2)
colormap gray
hold on

    # Draw the errorbars, with darkness indicating the proportion of
    # participants contributing to the estimate.
    lagColors <- 1-repmat((T1_nEstimates/nParticipantsTotal)',1,3)
    lagColors(:,thisRGB) <- ones(size(lagColors(:,thisRGB)))

    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_efficacy_SEM(thisLag)*[-1 1]+T1_efficacy_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
        line([standardLags(thisLag) standardLags(thisLag+1)],[T1_efficacy_M(thisLag) T1_efficacy_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T1_efficacy_M,[],lagColors)

# Plot latency
subplot(1,4,3)
hold on

    # Draw the errorbars for each lag.
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_latency_SEM(thisLag)*[-1 1]+T1_latency_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
        line([standardLags(thisLag) standardLags(thisLag+1)],[T1_latency_M(thisLag) T1_latency_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T1_latency_M,[],lagColors)

# Plot precision
subplot(1,4,4)
hold on

    # Draw the errorbars for each lag.
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_precision_SEM(thisLag)*[-1 1]+T1_precision_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
            line([standardLags(thisLag) standardLags(thisLag+1)],[T1_precision_M(thisLag) T1_precision_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T1_precision_M,[],lagColors)

# ---------------------------------------------------------------------
# This section contains code for creating the figure of T2 parameter
# estimates.

T2_Figure <- figure('color','white','name','Meta-Analysis: T2 Parameters')

# Plot efficacy
subplot(1,4,2)
colormap gray
hold on

    # Plot T1 bounds
    T1_lastLag_E <- standardEfficacy(:,nStandardLags,1,1)
    T1_Mean_E <- nanmean(T1_lastLag_E)
    T1_SD_E <- nanstd(T1_lastLag_E)
    T1_n_E <- sum(!isnan(T1_lastLag_E))
    T1_SEM_E <- T1_SD_E./sqrt(T1_n_E)

    line([0 standardLags(nStandardLags)],T1_Mean_E+T1_SEM_E*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_E-T1_SEM_E*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')

    # Draw the errorbars, with darkness indicating the proportion of
    # participants contributing to the estimate.
    lagColors <- 1-repmat((T2_nEstimates/nParticipantsTotal)',1,3)
    lagColors(:,thisRGB) <- ones(size(lagColors(:,thisRGB)))

    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_efficacy_SEM(thisLag)*[-1.96 1.96]+T2_efficacy_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
        line([standardLags(thisLag) standardLags(thisLag+1)],[T2_efficacy_M(thisLag) T2_efficacy_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T2_efficacy_M,[],lagColors)

# Plot latency
subplot(1,4,3)
hold on

    # Plot T1 bounds
    T1_lastLag_L <- standardLatency(:,nStandardLags,1,1)
    T1_Mean_L <- nanmean(T1_lastLag_L)
    T1_SD_L <- nanstd(T1_lastLag_L)
    T1_n_L <- sum(!isnan(T1_lastLag_L))
    T1_SEM_L <- T1_SD_L./sqrt(T1_n_L)

    line([0 standardLags(nStandardLags)],T1_Mean_L+T1_SEM_L*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_L-T1_SEM_L*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')

    # Draw the errorbars for each lag.
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_latency_SEM(thisLag)*[-1.96 1.96]+T2_latency_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
        line([standardLags(thisLag) standardLags(thisLag+1)],[T2_latency_M(thisLag) T2_latency_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T2_latency_M,[],lagColors)

# Plot precision
subplot(1,4,4)
hold on

    # Plot T1 bounds
    T1_lastLag_P <- standardPrecision(:,nStandardLags,1,1)
    T1_Mean_P <- nanmean(T1_lastLag_P)
    T1_SD_P <- nanstd(T1_lastLag_P)
    T1_n_P <- sum(!isnan(T1_lastLag_P))
    T1_SEM_P <- T1_SD_P./sqrt(T1_n_P)

    line([0 standardLags(nStandardLags)],T1_Mean_P+T1_SEM_P*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_P-T1_SEM_P*1.96*ones(1,2), 'Color', plotColor{1}, 'LineStyle', ':')

    # Draw the errorbars for each lag.
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_precision_SEM(thisLag)*[-1.96 1.96]+T2_precision_M(thisLag), 'Color', lagColors(thisLag,:))
    }

    # Draw the lines joining icons for each lag.
    for (thisLag in 1:nStandardLags-1){
            line([standardLags(thisLag) standardLags(thisLag+1)],[T2_precision_M(thisLag) T2_precision_M(thisLag+1)], 'Color', lagColors(thisLag,:))
    }

    # Draw the icons for each lag.
    scatter(standardLags,T2_precision_M,[],lagColors)


# Now add the data points for the Vul et al. analysis.

# First, for T2:

    # Calculate mean parameters across participants.
    T2_efficacy_M <- nanmean(squeeze(standardEfficacy(:,:,2,2)))
    T2_latency_M <- nanmean(squeeze(standardLatency(:,:,2,2)))
    T2_precision_M <- nanmean(squeeze(standardPrecision(:,:,2,2)))

    # Calculate standard deviations across participants.
    T2_efficacy_SD <- nanstd(squeeze(standardEfficacy(:,:,2,2)))
    T2_latency_SD <- nanstd(squeeze(standardLatency(:,:,2,2)))
    T2_precision_SD <- nanstd(squeeze(standardPrecision(:,:,2,2)))

    # Tally the number of participants contributing to these means.
    T2_nEstimates <- sum(!isnan(squeeze(standardEfficacy(:,:,2,2))))

    # Calculate the standard error of the mean.
    T2_efficacy_SEM <- T2_efficacy_SD./sqrt(T2_nEstimates)
    T2_latency_SEM <- T2_latency_SD./sqrt(T2_nEstimates)
    T2_precision_SEM <- T2_precision_SD./sqrt(T2_nEstimates)

# Then, for T1:

    # Calculate mean parameters across participants.
    T1_efficacy_M <- nanmean(squeeze(standardEfficacy(:,:,1,2)))
    T1_latency_M <- nanmean(squeeze(standardLatency(:,:,1,2)))
    T1_precision_M <- nanmean(squeeze(standardPrecision(:,:,1,2)))

    # Calculate standard deviations across participants.
    T1_efficacy_SD <- nanstd(squeeze(standardEfficacy(:,:,1,2)))
    T1_latency_SD <- nanstd(squeeze(standardLatency(:,:,1,2)))
    T1_precision_SD <- nanstd(squeeze(standardPrecision(:,:,1,2)))

    # Tally the number of participants contributing to these means.
    T1_nEstimates <- sum(!isnan(squeeze(standardEfficacy(:,:,1,2))))

    # Calculate the standard error of the mean.
    T1_efficacy_SEM <- T1_efficacy_SD./sqrt(T1_nEstimates)
    T1_latency_SEM <- T1_latency_SD./sqrt(T1_nEstimates)
    T1_precision_SEM <- T1_precision_SD./sqrt(T1_nEstimates)


    # Conduct t-tests as a rough guide to whether the parameter estimates
    # for T2 at each lag differ from a T1 baseline.

    # Create empty matrices to store p-values
    pVals <- NaN(1,nStandardLags)
    pVals_E <- NaN(1,nStandardLags)
    pVals_L <- NaN(1,nStandardLags)
    pVals_P <- NaN(1,nStandardLags)

    # Cycle through each lag to conduct the t-tests
    for (thisLag in 1:nStandardLags){

            # T2 contingent accuracy t-test
            [h,p] <- ttest(squeeze(standardAccuracy(:,thisLag,2)),standardAccuracy(:,nStandardLags,1))
            pVals(thisLag) <- p

            # Efficacy t-test
            [h,p] <- ttest(squeeze(standardEfficacy(:,thisLag,2,2)),standardEfficacy(:,nStandardLags,1,2))
            pVals_E(thisLag) <- p

            # Latency t-test
            [h,p] <- ttest(squeeze(standardLatency(:,thisLag,2,2)),standardLatency(:,nStandardLags,1,2))
            pVals_L(thisLag) <- p

            # Precision t-test
            [h,p] <- ttest(squeeze(standardPrecision(:,thisLag,2,2)),standardPrecision(:,nStandardLags,1,2))
            pVals_P(thisLag) <- p

    }


# ---------------------------------------------------------------------
# This section contains code for printing the outcome of these t-tests
# to the command window.

fprintf('\nContingent Accuracy\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d ', pVals(thisL) < alphaVal)
}
fprintf('\t|\n')

fprintf('\nEfficacy (Formula)\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_E(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_E(thisL) < alphaVal)
}
fprintf('\t|\n')

fprintf('\nLatency (Formula)\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_L(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_L(thisL) < alphaVal)
}
fprintf('\t|\n')

fprintf('\nPrecision (Formula)\n')

for (thisL in 1:nStandardLags){
    fprintf('\t| L %d', thisL)
}
fprintf('\t|\n')

fprintf('P')
for (thisL in 1:nStandardLags){
    fprintf('\t| %.3f', pVals_P(thisL))
}
fprintf('\t|\n')

fprintf('H')
for (thisL in 1:nStandardLags){
    fprintf('\t| %d', pVals_P(thisL) < alphaVal)
}

fprintf('\t|\n\n\n')

# ---------------------------------------------------------------------
# This section contains code for creating the figure of T1 parameter
# estimates.

# Select the T1 figure
figure(T1_Figure)

# Plot efficacy
subplot(1,4,2)
hold on

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
       line([standardLags(thisLag) standardLags(thisLag)],T1_efficacy_SEM(thisLag)*[-1 1]+T1_efficacy_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T1_efficacy_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -0.1 1.1])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

# Plot latency
subplot(1,4,3)
hold on

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_latency_SEM(thisLag)*[-1 1]+T1_latency_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T1_latency_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -180 180])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

# Plot precision
subplot(1,4,4)
hold on

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_precision_SEM(thisLag)*[-1 1]+T1_precision_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T1_precision_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -20 220])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on','YDir','Reverse')
    box on
    axis square

# Plot accuracy
subplot(1,4,1)
hold on

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T1_accuracy_SEM(thisLag)*[-1 1]+T1_accuracy_M(thisLag), 'Color', plotColor{3})
    }

    # Plot parameter estimates
    plot(standardLags,T1_accuracy_M,plotIcon{3})

    # Set axis properties
    axis([-80 880 -0.1 1.1])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

#---------------------------------------------------------------------
# This section contains code for creating the figure of T2 parameter
# estimates.

# Select the T2 figure
figure(T2_Figure)

# Plot efficacy
subplot(1,4,2)
hold on

    # Plot T1 bounds
    T1_lastLag_E <- standardEfficacy(:,nStandardLags,1,2)
    T1_Mean_E <- nanmean(T1_lastLag_E)
    T1_SD_E <- nanstd(T1_lastLag_E)
    T1_n_E <- sum(!isnan(T1_lastLag_E))
    T1_SEM_E <- T1_SD_E./sqrt(T1_n_E)

    line([0 standardLags(nStandardLags)],T1_Mean_E+T1_SEM_E*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_E-T1_SEM_E*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
       line([standardLags(thisLag) standardLags(thisLag)],T2_efficacy_SEM(thisLag)*[-1.96 1.96]+T2_efficacy_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T2_efficacy_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -0.1 1.1])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

# Plot latency
subplot(1,4,3)
hold on

    # Plot T1 bounds
    T1_lastLag_L <- standardLatency(:,nStandardLags,1,2)
    T1_Mean_L <- nanmean(T1_lastLag_L)
    T1_SD_L <- nanstd(T1_lastLag_L)
    T1_n_L <- sum(!isnan(T1_lastLag_L))
    T1_SEM_L <- T1_SD_L./sqrt(T1_n_L)

    line([0 standardLags(nStandardLags)],T1_Mean_L+T1_SEM_L*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_L-T1_SEM_L*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_latency_SEM(thisLag)*[-1.96 1.96]+T2_latency_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T2_latency_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -180 180])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

# Plot precision
subplot(1,4,4)
hold on

    # Plot T1 bounds
    T1_lastLag_P <- standardPrecision(:,nStandardLags,1,2)
    T1_Mean_P <- nanmean(T1_lastLag_P)
    T1_SD_P <- nanstd(T1_lastLag_P)
    T1_n_P <- sum(!isnan(T1_lastLag_P))
    T1_SEM_P <- T1_SD_P./sqrt(T1_n_P)

    line([0 standardLags(nStandardLags)],T1_Mean_P+T1_SEM_P*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_P-T1_SEM_P*1.96*ones(1,2), 'Color', plotColor{2}, 'LineStyle', ':')

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_precision_SEM(thisLag)*[-1.96 1.96]+T2_precision_M(thisLag), 'Color', plotColor{2})
    }

    # Plot parameter estimates
    plot(standardLags,T2_precision_M,plotIcon{2})

    # Set axis properties
    axis([-80 880 -20 220])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on','YDir','Reverse')
    box on
    axis square

# Plot accuracy
subplot(1,4,1)
hold on

    # Plot T1 bounds
    T1_lastLag_A <- standardAccuracy(:,nStandardLags,1)
    T1_Mean_A <- nanmean(T1_lastLag_A)
    T1_SD_A <- nanstd(T1_lastLag_A)
    T1_n_A <- sum(!isnan(T1_lastLag_A))
    T1_SEM_A <- T1_SD_A./sqrt(T1_n_A)

    line([0 standardLags(nStandardLags)],T1_Mean_A+T1_SEM_A*1.96*ones(1,2), 'Color', plotColor{3}, 'LineStyle', ':')
    line([0 standardLags(nStandardLags)],T1_Mean_A-T1_SEM_A*1.96*ones(1,2), 'Color', plotColor{3}, 'LineStyle', ':')

    # Draw errorbars
    for (thisLag in 1:nStandardLags){
        line([standardLags(thisLag) standardLags(thisLag)],T2_accuracy_SEM(thisLag)*[-1.96 1.96]+T2_accuracy_M(thisLag), 'Color', plotColor{3})
    }

    # Plot parameter estimates
    plot(standardLags,T2_accuracy_M,plotIcon{3})

    # Set axis properties
    axis([-80 880 -0.1 1.1])
    set(gca,'TickDir','out','XMinorTick','on','YMinorTick','on')
    box on
    axis square

# Work out proportion of excluded models
excludedModels <- (sum(dumpedOnEfficacyLimit)+sum(dumpedOnLatencyLimit)+sum(dumpedOnPrecisionLimit))/(2*sum(allNParticipants.*allNLags))
fprintf('\n\n%.1f%% of models excluded.\n\n', 100*excludedModels)
